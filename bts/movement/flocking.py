import numpy as np

def cohesion(pos, nbs_pos, strength):
    """
    Move towards the center of neighbours
    """
    center = np.mean(np.array(nbs_pos), 0)
    v_c = strength*(center - pos)
    return v_c

def separation(pos, nbs_pos, strength):
    """
    Double the distance away from each neighbour
    """
    v_s = strength*(len(nbs_pos)*pos-np.sum(np.array(nbs_pos), 0))
    return v_s

def alignment(vel, nbs_vel, strength):
    """
    Align velocities to the average velocity
    """
    avge_vel = np.mean(np.array(nbs_vel), 0)
    v_a = strength*(avge_vel-vel)
    return v_a

def sum_vels(*args):
    """
    Sum each constituent velocity together 
    """
    vel = np.sum(args, 0)
    return vel

def update_vel(agent):
    """
    Update velocity 
    """
    # Gather neighbours
    inner_nbs = agent.neighbors(agent, distance=agent.p.inner_radius)
    outer_nbs = agent.neighbors(agent, distance=agent.p.outer_radius)
    # Apply flocking rules
    v_c = cohesion(agent.pos, outer_nbs.pos, agent.p.cohesion_strength)
    v_s = separation(agent.pos, inner_nbs.pos, agent.p.separation_strength)
    v_a = alignment(agent.vel, outer_nbs.vel, agent.p.alignment_strength)
    # Add current velocity to velocities generated by flocking rules for new velocity
    new_vel = sum_vels(agent.vel, v_c, v_s, v_a)
    return new_vel